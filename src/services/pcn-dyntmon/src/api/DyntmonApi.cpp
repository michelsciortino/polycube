/**
* dyntmon API generated from dyntmon.yang
*
* NOTE: This file is auto generated by polycube-codegen
* https://github.com/polycube-network/polycube-codegen
*/


/* Do not edit this file manually */


#include "DyntmonApi.h"
#include "DyntmonApiImpl.h"

using namespace polycube::service::model;
using namespace polycube::service::api::DyntmonApiImpl;

#ifdef __cplusplus
extern "C" {
#endif

Response create_dyntmon_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DyntmonJsonObject unique_value { request_body };
    unique_value.setName(unique_name);
    create_dyntmon_by_id(unique_name, unique_value);
    return { kCreated, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response create_dyntmon_dataplane_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneJsonObject unique_value { request_body };
    create_dyntmon_dataplane_by_id(unique_name, unique_value);
    return { kCreated, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response create_dyntmon_dataplane_metrics_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneMetricsJsonObject unique_value { request_body };
    unique_value.setName(unique_metricsName);
    create_dyntmon_dataplane_metrics_by_id(unique_name, unique_metricsName, unique_value);
    return { kCreated, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response create_dyntmon_dataplane_metrics_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  // Getting the body param
  std::vector<DataplaneMetricsJsonObject> unique_value;
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    std::vector<DataplaneMetricsJsonObject> unique_value;
    for (auto &j : request_body) {
      DataplaneMetricsJsonObject a { j };
      unique_value.push_back(a);
    }
    create_dyntmon_dataplane_metrics_list_by_id(unique_name, unique_value);
    return { kCreated, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response create_dyntmon_dataplane_metrics_open_metrics_metadata_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneMetricsOpenMetricsMetadataJsonObject unique_value { request_body };
    create_dyntmon_dataplane_metrics_open_metrics_metadata_by_id(unique_name, unique_metricsName, unique_value);
    return { kCreated, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response create_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  std::string unique_labelName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "label_name")) {
      unique_labelName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneMetricsOpenMetricsMetadataLabelJsonObject unique_value { request_body };
    unique_value.setName(unique_labelName);
    create_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id(unique_name, unique_metricsName, unique_labelName, unique_value);
    return { kCreated, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response create_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  // Getting the body param
  std::vector<DataplaneMetricsOpenMetricsMetadataLabelJsonObject> unique_value;
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    std::vector<DataplaneMetricsOpenMetricsMetadataLabelJsonObject> unique_value;
    for (auto &j : request_body) {
      DataplaneMetricsOpenMetricsMetadataLabelJsonObject a { j };
      unique_value.push_back(a);
    }
    create_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id(unique_name, unique_metricsName, unique_value);
    return { kCreated, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response create_dyntmon_dataplane_reload_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto x = create_dyntmon_dataplane_reload_by_id(unique_name);
    nlohmann::json response_body;
    response_body = x.toJson();
    return { kCreated, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response delete_dyntmon_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    delete_dyntmon_by_id(unique_name);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response delete_dyntmon_dataplane_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    delete_dyntmon_dataplane_by_id(unique_name);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response delete_dyntmon_dataplane_metrics_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    delete_dyntmon_dataplane_metrics_by_id(unique_name, unique_metricsName);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response delete_dyntmon_dataplane_metrics_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    delete_dyntmon_dataplane_metrics_list_by_id(unique_name);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response delete_dyntmon_dataplane_metrics_open_metrics_metadata_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    delete_dyntmon_dataplane_metrics_open_metrics_metadata_by_id(unique_name, unique_metricsName);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response delete_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i) 
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  std::string unique_labelName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "label_name")) {
      unique_labelName = std::string { keys[i].value.string };
      break;
    }
  try {
    delete_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id(unique_name, unique_metricsName, unique_labelName);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response delete_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    delete_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id(unique_name, unique_metricsName);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto x = read_dyntmon_by_id(unique_name);
    nlohmann::json response_body;
    response_body = x.toJson();
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto x = read_dyntmon_dataplane_by_id(unique_name);
    nlohmann::json response_body;
    response_body = x.toJson();
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_code_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto x = read_dyntmon_dataplane_code_by_id(unique_name);
    nlohmann::json response_body;
    response_body = x;
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_metrics_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_dataplane_metrics_by_id(unique_name, unique_metricsName);
    nlohmann::json response_body;
    response_body = x.toJson();
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_metrics_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto x = read_dyntmon_dataplane_metrics_list_by_id(unique_name);
    nlohmann::json response_body;
    for (auto &i : x)
      response_body += i.toJson();
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_metrics_map_name_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_dataplane_metrics_map_name_by_id(unique_name, unique_metricsName);
    nlohmann::json response_body;
    response_body = x;
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_metrics_open_metrics_metadata_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_dataplane_metrics_open_metrics_metadata_by_id(unique_name, unique_metricsName);
    nlohmann::json response_body;
    response_body = x.toJson();
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_metrics_open_metrics_metadata_help_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_dataplane_metrics_open_metrics_metadata_help_by_id(unique_name, unique_metricsName);
    nlohmann::json response_body;
    response_body = x;
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  std::string unique_labelName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "label_name")) {
      unique_labelName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id(unique_name, unique_metricsName, unique_labelName);
    nlohmann::json response_body;
    response_body = x.toJson();
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id(unique_name, unique_metricsName);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_metrics_open_metrics_metadata_label_value_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  std::string unique_labelName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "label_name")) {
      unique_labelName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_dataplane_metrics_open_metrics_metadata_label_value_by_id(unique_name, unique_metricsName, unique_labelName);
    nlohmann::json response_body;
    response_body = x;
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_metrics_open_metrics_metadata_type_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_dataplane_metrics_open_metrics_metadata_type_by_id(unique_name, unique_metricsName);
    nlohmann::json response_body;
    response_body = DataplaneMetricsOpenMetricsMetadataJsonObject::DataplaneMetricsOpenMetricsMetadataTypeEnum_to_string(x);
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_dataplane_name_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto x = read_dyntmon_dataplane_name_by_id(unique_name);
    nlohmann::json response_body;
    response_body = x;
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  try {
    auto x = read_dyntmon_list_by_id();
    nlohmann::json response_body;
    for (auto &i : x)
      response_body += i.toJson();
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_metrics_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_metrics_by_id(unique_name, unique_metricsName);
    nlohmann::json response_body;
    response_body = x.toJson();
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_metrics_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto x = read_dyntmon_metrics_list_by_id(unique_name);
    nlohmann::json response_body;
    for (auto &i : x)
      response_body += i.toJson();
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_metrics_timestamp_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_metrics_timestamp_by_id(unique_name, unique_metricsName);
    nlohmann::json response_body;
    response_body = x;
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_metrics_value_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto x = read_dyntmon_metrics_value_by_id(unique_name, unique_metricsName);
    nlohmann::json response_body;
    response_body = x;
    return { kOk, ::strdup(response_body.dump().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response read_dyntmon_open_metrics_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto x = read_dyntmon_open_metrics_by_id(unique_name);
    nlohmann::json response_body;
    response_body = x;
    return { kOk, ::strdup(response_body.get<std::string>().c_str()) };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response replace_dyntmon_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DyntmonJsonObject unique_value { request_body };
    unique_value.setName(unique_name);
    replace_dyntmon_by_id(unique_name, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response replace_dyntmon_dataplane_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneJsonObject unique_value { request_body };
    replace_dyntmon_dataplane_by_id(unique_name, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response replace_dyntmon_dataplane_metrics_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string{ keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneMetricsJsonObject unique_value { request_body };
    unique_value.setName(unique_metricsName);
    replace_dyntmon_dataplane_metrics_by_id(unique_name, unique_metricsName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response replace_dyntmon_dataplane_metrics_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  // Getting the body param
  std::vector<DataplaneMetricsJsonObject> unique_value;
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    std::vector<DataplaneMetricsJsonObject> unique_value;
    for (auto &j : request_body) {
      DataplaneMetricsJsonObject a { j };
      unique_value.push_back(a);
    }
    replace_dyntmon_dataplane_metrics_list_by_id(unique_name, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response replace_dyntmon_dataplane_metrics_open_metrics_metadata_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneMetricsOpenMetricsMetadataJsonObject unique_value { request_body };
    replace_dyntmon_dataplane_metrics_open_metrics_metadata_by_id(unique_name, unique_metricsName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response replace_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  std::string unique_labelName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "label_name")) {
      unique_labelName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneMetricsOpenMetricsMetadataLabelJsonObject unique_value { request_body };
    unique_value.setName(unique_labelName);
    replace_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id(unique_name, unique_metricsName, unique_labelName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response replace_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  // Getting the body param
  std::vector<DataplaneMetricsOpenMetricsMetadataLabelJsonObject> unique_value;
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    std::vector<DataplaneMetricsOpenMetricsMetadataLabelJsonObject> unique_value;
    for (auto &j : request_body) {
      DataplaneMetricsOpenMetricsMetadataLabelJsonObject a { j };
      unique_value.push_back(a);
    }
    replace_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id(unique_name, unique_metricsName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DyntmonJsonObject unique_value { request_body };
    unique_value.setName(unique_name);
    update_dyntmon_by_id(unique_name, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneJsonObject unique_value { request_body };
    update_dyntmon_dataplane_by_id(unique_name, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_code_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // The conversion is done automatically by the json library
    std::string unique_value = request_body;
    update_dyntmon_dataplane_code_by_id(unique_name, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_metrics_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneMetricsJsonObject unique_value { request_body };
    unique_value.setName(unique_metricsName);
    update_dyntmon_dataplane_metrics_by_id(unique_name, unique_metricsName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_metrics_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  // Getting the body param
  std::vector<DataplaneMetricsJsonObject> unique_value;

  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    std::vector<DataplaneMetricsJsonObject> unique_value;
    for (auto &j : request_body) {
      DataplaneMetricsJsonObject a { j };
      unique_value.push_back(a);
    }
    update_dyntmon_dataplane_metrics_list_by_id(unique_name, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_metrics_map_name_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // The conversion is done automatically by the json library
    std::string unique_value = request_body;
    update_dyntmon_dataplane_metrics_map_name_by_id(unique_name, unique_metricsName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_metrics_open_metrics_metadata_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneMetricsOpenMetricsMetadataJsonObject unique_value { request_body };
    update_dyntmon_dataplane_metrics_open_metrics_metadata_by_id(unique_name, unique_metricsName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_metrics_open_metrics_metadata_help_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i) {
    if (!strcmp(keys[i].name, "metrics_name"))
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // The conversion is done automatically by the json library
    std::string unique_value = request_body;
    update_dyntmon_dataplane_metrics_open_metrics_metadata_help_by_id(unique_name, unique_metricsName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  std::string unique_labelName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "label_name")) {
      unique_labelName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    DataplaneMetricsOpenMetricsMetadataLabelJsonObject unique_value { request_body };
    unique_value.setName(unique_labelName);
    update_dyntmon_dataplane_metrics_open_metrics_metadata_label_by_id(unique_name, unique_metricsName, unique_labelName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  // Getting the body param
  std::vector<DataplaneMetricsOpenMetricsMetadataLabelJsonObject> unique_value;
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    std::vector<DataplaneMetricsOpenMetricsMetadataLabelJsonObject> unique_value;
    for (auto &j : request_body) {
      DataplaneMetricsOpenMetricsMetadataLabelJsonObject a { j };
      unique_value.push_back(a);
    }
    update_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id(unique_name, unique_metricsName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_metrics_open_metrics_metadata_label_value_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  std::string unique_labelName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "label_name")) {
      unique_labelName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // The conversion is done automatically by the json library
    std::string unique_value = request_body;
    update_dyntmon_dataplane_metrics_open_metrics_metadata_label_value_by_id(unique_name, unique_metricsName, unique_labelName, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_metrics_open_metrics_metadata_type_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    DataplaneMetricsOpenMetricsMetadataTypeEnum unique_value_ = DataplaneMetricsOpenMetricsMetadataJsonObject::string_to_DataplaneMetricsOpenMetricsMetadataTypeEnum(request_body);
    update_dyntmon_dataplane_metrics_open_metrics_metadata_type_by_id(unique_name, unique_metricsName, unique_value_);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_dataplane_name_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the path params
  std::string unique_name { name };
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // The conversion is done automatically by the json library
    std::string unique_value = request_body;
    update_dyntmon_dataplane_name_by_id(unique_name, unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}

Response update_dyntmon_list_by_id_handler(
  const char *name, const Key *keys,
  size_t num_keys ,
  const char *value) {
  // Getting the body param
  std::vector<DyntmonJsonObject> unique_value;
  try {
    auto request_body = nlohmann::json::parse(std::string { value });
    // Getting the body param
    std::vector<DyntmonJsonObject> unique_value;
    for (auto &j : request_body) {
      DyntmonJsonObject a { j };
      unique_value.push_back(a);
    }
    update_dyntmon_list_by_id(unique_value);
    return { kOk, nullptr };
  } catch(const std::exception &e) {
    return { kGenericError, ::strdup(e.what()) };
  }
}


Response dyntmon_dataplane_metrics_list_by_id_help(
  const char *name, const Key *keys, size_t num_keys) {
  // Getting the path params
  std::string unique_name { name };
  nlohmann::json val = read_dyntmon_dataplane_metrics_list_by_id_get_list(unique_name);
  return { kOk, ::strdup(val.dump().c_str()) };
}

Response dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id_help(
  const char *name, const Key *keys, size_t num_keys) {
  // Getting the path params
  std::string unique_name { name };
  std::string unique_metricsName;
  for (size_t i = 0; i < num_keys; ++i)
    if (!strcmp(keys[i].name, "metrics_name")) {
      unique_metricsName = std::string { keys[i].value.string };
      break;
    }
  nlohmann::json val = read_dyntmon_dataplane_metrics_open_metrics_metadata_label_list_by_id_get_list(unique_name, unique_metricsName);
  return { kOk, ::strdup(val.dump().c_str()) };
}

Response dyntmon_list_by_id_help(
  const char *name, const Key *keys, size_t num_keys) {
  nlohmann::json val = read_dyntmon_list_by_id_get_list();
  return { kOk, ::strdup(val.dump().c_str()) };
}

Response dyntmon_metrics_list_by_id_help(
  const char *name, const Key *keys, size_t num_keys) {
  // Getting the path params
  std::string unique_name { name };
  nlohmann::json val = read_dyntmon_metrics_list_by_id_get_list(unique_name);
  return { kOk, ::strdup(val.dump().c_str()) };
}

#ifdef __cplusplus
}
#endif
